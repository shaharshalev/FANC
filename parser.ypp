%{
	#define YYDEBUG 1
	#define YYERROR_VERBOSE 1
	#include <iostream>
	#include <stdlib.h>
	#include "parser.hpp"
	#include "output.hpp"
	extern int yylineno;
	int yyerror(const char * message);
	int yylex();

	vector<Scope*> table;
	vector<int> offsets;
%}

%left ASSIGN
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%nonassoc IFPREC
%left ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token PRECOND
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%left OR
%left AND
%left EQUALITY
%left RELATIONAL
%left ADDITIVE 
%left MULTIPLICATIVE 
%token LPAREN
%token RPAREN


%%

Program:	Funcs	{}
;

Funcs: /*epsilon*/ {}
	| FuncDecl Funcs	{} 
;

FuncDecl:	RetType ID LPAREN Formals RPAREN PreConditions LBRACE OpenFunctionScope Statements RBRACE {}
;

RetType:	Type {}
	|		VOID {}
;

Formals:	/*epsilon*/ {}
	|	FormalsList {}
;

FormalsList:	FormalDecl	{}
	|	FormalDecl	COMMA FormalsList {}
;

FormalDecl:	Type ID {}
;

PreConditions:	/*epsilon*/ {}
	|	PreConditions PreCondition {}
;

PreCondition:	PRECOND LPAREN Exp RPAREN {}
;

Statements: Statement	{}
	|	Statements Statement {}
;

Statement: LBRACE OpenScope Statements RBRACE	{}
	|	Type ID	SC	{}
	|	Type ID ASSIGN Exp SC	{}
	|	ID ASSIGN Exp SC	{}
	|	Call SC	{}
	|	RETURN SC	{}
	|	RETURN Exp SC	{}
	|	IF LPAREN Exp RPAREN OpenIfScope Statement ELSE EndScope OpenScope Statement 	{}
	|	IF LPAREN Exp RPAREN OpenIfScope Statement %prec IFPREC {}
	|	WHILE LPAREN Exp RPAREN OpenWhileScope Statement	{}
	|	BREAK SC	{}
	|	CONTINUE SC	{}
;

Call:	ID LPAREN ExpList RPAREN	{}
	|	ID LPAREN RPAREN	{}
;

ExpList: Exp	{}
	|	Exp COMMA ExpList	{}
;

Type: INT	{}
	| BYTE	{}
	| BOOL	{}
;

Exp:	LPAREN Exp RPAREN	{}
	|	Exp MULTIPLICATIVE Exp	{}
	|	Exp ADDITIVE Exp	{}
	|	ID		{}
	|	Call	{}
	|	NUM B	{$$ = new Byte((Number*)$1); }
	|	NUM		{$$ = new Integer((Number*)$1); }
	|	STRING	{$$ = (String*)$1;}
	|	TRUE	{$$ = new Boolean(true);}
	|	FALSE	{$$ = new Boolean(false);}
	|	NOT Exp	{$$ = new Not((Expression*)$2)}
	|	Exp AND Exp	{}
	|	Exp OR Exp	{}
	|	Exp RELATIONAL Exp {}
	|	Exp EQUALITY Exp {}
;

OpenWhileScope: /*epsilon*/ {}
;

OpenIfScope: /*epsilon*/ {}
;

OpenFunctionScope: /*epsilon*/ {}
;

OpenScope: /*epsilon*/ {}
;

EndScope: /*epsilon*/ {}
;





%%

int main(){
	//yydebug=1 // uncomment this inorder to debug
	return yyparse();
}
int yyerror(const char * message){
	errorSyn(yylineno);
	exit(1);
}
