%{
	#define YYDEBUG 1
	#define YYERROR_VERBOSE 1
	#include <iostream>
	#include <stdlib.h>
	#include "fanC.hpp"
	#include "output.hpp"
	#include <assert.h>     /* assert */
	extern int yylineno;
	int yyerror(const char * message);
	int yylex();
	void handleWhile(Expression* exp);
	void validateExpIsBool(Expression* exp);
	void validateWhile(WhileOp op);
    bool inWhile();
    void validateFunctionReturnType(Expression* exp);
    void validateAssignment(Id* id,Expression* exp);
    void insertVarToTable(Id* id);
    void handleTypeDecl(Type* type,Id* id);
    Id* extractIdFromSymbolTable(Id* id);
    void assignToVar(Id* id,Expression* exp);
    void handleIf(Expression* exp);
    FuncDec* getFunction();
    void handleArgumentDecl(FormalList* formalList);
    Call* handleCall(Id* id,ExpressionList* expList);
    void assertIdentifierNotExists(Id* id);
    void handleIDExpression(Id* id);
    void validateMain(Id* id,FormalList* formals,ReturnType* returnType);

	vector<Scope*> symbolTable;
	vector<int> offsets;
	bool isMainExist=false;
%}

%left ASSIGN
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%nonassoc IFPREC
%left ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token PRECOND
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%left OR
%left AND
%nonassoc EQUALITY
%nonassoc RELATIONAL
%left ADDITIVE 
%left MULTIPLICATIVE 
%token LPAREN
%token RPAREN


%%

Program:	OpenScope Funcs	{
    if(!isMainExist){
        errorMainMissing();
        exit(1);
    }
    symbolTable.back()->endScope();
}
;

Funcs: /*epsilon*/ {}
	| FuncDecl Funcs	{} 
;

FuncDecl:	FuncDeclSignature PreConditionsDecl LBRACE  Statements RBRACE {symbolTable.back()->endScope();}
;

FuncDeclSignature:OpenFunctionScope RetType ID LPAREN Formals RPAREN  {
     ReturnType* returnType=dynamic_cast<ReturnType*>($2);
     Id* id=dynamic_cast<Id*>($3);
     FormalList* formals=dynamic_cast<FormalList*>($5);
     assertIdentifierNotExists(id);
     validateMain(id,formals,returnType);
     FunctionScope* functionScope=dynamic_cast<FunctionScope*>(symbolTable.back());
     functionScope->updateFunctionScope(new FuncDec(returnType,id,formals,NULL));
}
;

PreConditionsDecl: PreConditions {
     PreConditions* preconditions=dynamic_cast<PreConditions*>($1);
     Id * i = preconditions->isValid();
     if(i!=NULL){
        errorUndef(yylineno,i->name);
        exit(1);
     }
     FunctionScope* functionScope=dynamic_cast<FunctionScope*>(symbolTable.back());
     functionScope->updateFunctionScope(preconditions);
};

RetType:	Type {$$ = $1;}
	|		VOID {$$ = new Void();}
;

Formals:	/*epsilon*/ {$$ = new FormalList();}
	| 	FormalsList {handleArgumentDecl((FormalList*)$1);$$ = (FormalList*)$1;}
;

FormalsList:	FormalDecl	{$$=new FormalList((FormalDec*)$1);}
	|	FormalDecl	COMMA FormalsList {$$=((FormalList*)$3)->add((FormalDec*)$1);}
;

FormalDecl:	Type ID {
    Type* type=(Type*)$1;
    Id* id=(Id*)$2;
    id->updateType(type);
    $$=new FormalDec(type,id);
}
;

PreConditions:	/*epsilon*/ {$$=new PreConditions();}
	|	PreConditions PreCondition {$$=((PreConditions*)$1)->add((PreCondition*)$2);}
;

PreCondition:	PRECOND LPAREN Exp RPAREN {validateExpIsBool((Expression*)$3); $$=new PreCondition((Expression*)$3);}
;

Statements: Statement	{}
	|	Statements Statement {}
;

Statement: LBRACE OpenScope Statements RBRACE	{symbolTable.back()->endScope();}
	|	Type ID	SC	{handleTypeDecl((Type*)$1,(Id*)$2);}
	|	Type ID ASSIGN Exp SC	{handleTypeDecl((Type*)$1,(Id*)$2);validateAssignment((Id*)$2,(Expression*)$4); delete $4;}
	|	ID ASSIGN Exp SC	{assignToVar((Id*)$1,(Expression*)$3);}
	|	Call SC	{delete $1; }
	|	RETURN SC	{validateFunctionReturnType(NULL);}
	|	RETURN Exp SC	{validateFunctionReturnType((Expression*)$2);}
	|	IF LPAREN Exp RPAREN OpenScope Statement ELSE EndScope OpenScope Statement 	{handleIf((Expression*)$3);}
	|	IF LPAREN Exp RPAREN OpenScope Statement %prec IFPREC {handleIf((Expression*)$3);}
	|	WHILE LPAREN Exp RPAREN OpenWhileScope Statement	{handleWhile((Expression*)$3);}
	|	BREAK SC	{validateWhile(Break);}
	|	CONTINUE SC	{validateWhile(Continue);}
;

Call:	ID LPAREN ExpList RPAREN	{$$=handleCall((Id*)$1,(ExpressionList*)$3);}
	|	ID LPAREN RPAREN	{$$ = handleCall(((Id*)$1),new ExpressionList());}
;

ExpList: Exp	{$$=new ExpressionList((Expression*)$1);}
	|	Exp COMMA ExpList	{$$=((ExpressionList*)$3)->add((Expression*)$1);}
;

Type: INT	{$$=new IntType();}
	| BYTE	{$$=new ByteType();}
	| BOOL	{$$=new BooleanType();}
;

Exp:	LPAREN Exp RPAREN	{$$ = $2;}
	|	Exp MULTIPLICATIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	Exp ADDITIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	ID		{handleIDExpression((Id*)$1);$$ = (Id*)$1;}
	|	Call	{$$ = (Call*)$1; }
	|	NUM B	{$$ = new Byte((Number*)$1); }
	|	NUM		{$$ = new Integer((Number*)$1); }
	|	STRING	{$$ = (String*)$1;}
	|	TRUE	{$$ = new Boolean(true);}
	|	FALSE	{$$ = new Boolean(false);}
	|	NOT Exp	{$$ = new Not((Expression*)$2);}
	|	Exp AND Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(And));}
	|	Exp OR Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(Or));}
	|	Exp RELATIONAL Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);}
	|	Exp EQUALITY Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);}
;

OpenWhileScope: /*epsilon*/ {
    symbolTable.push_back(new WhileScope(symbolTable.back()));
    offsets.push_back(offsets.back());
}
;



/* todo: check there is one main with void and no args*/

OpenScope: /*epsilon*/ {
    if(symbolTable.empty()){
        assert(offsets.empty());
        symbolTable.push_back(new Scope(NULL));
        offsets.push_back(0);
        /*TODO : insert print and iprint*/
    }else{
        symbolTable.push_back(new Scope(symbolTable.back()));
        offsets.push_back(offsets.back());
    }
}
;

OpenFunctionScope: {
    symbolTable.push_back(new FunctionScope(symbolTable.back()));
    offsets.push_back(offsets.back());
}
;

EndScope: /*epsilon*/ {
    Scope* currentScope = symbolTable.back();
    symbolTable.pop_back();
    offsets.pop_back();
    currentScope->endScope();
    delete currentScope;
}
;





%%

int main(){
	//yydebug=1 // uncomment this inorder to debug
	return yyparse();
}
int yyerror(const char * message){
	errorSyn(yylineno);
	exit(1);
}

void validateMain(Id* id ,FormalList* formals ,ReturnType* returnType){
    if(id->name == "main"){
        if(returnType->typeName() != "VOID" || formals->size() != 0){
            errorMismatch(yylineno);
            exit(1);
            //todo validate error
           }
           if(isMainExist) {
               errorDef(yylineno,"main");
               exit(1);
           }
           isMainExist = true;
       }

   }

void validateWhile(WhileOp op){
    if(inWhile()){
        switch(op){
            case Break:
                errorUnexpectedBreak(yylineno);
            break;
            case Continue:
                errorUnexpectedContinue(yylineno);
            break;
        }
    }
}
void validateExpIsBool(Expression* exp){
  if(!isInstanceOf<BooleanType>(exp)){
       errorMismatch(yylineno);
       exit(1);
  }
}

void handleWhile(Expression* exp){
    validateExpIsBool(exp);
    symbolTable.back()->endScope();
    delete exp;
}

bool inWhile(){
    for(vector<Scope*>::reverse_iterator i = symbolTable.rbegin();i != symbolTable.rend(); ++i){
        Scope* scope=*i;
        if(isInstanceOf<WhileScope>(scope)) return true;
    }
    return false;
}
/**
* The function returns the function of the scope that we are in.
* null is returned if we are not in a function.
*/
FuncDec* getFunction(){
 for(vector<Scope*>::reverse_iterator i = symbolTable.rbegin();i != symbolTable.rend(); ++i){
        Scope* scope=*i;
        if(isInstanceOf<FunctionScope>(scope)) {
            FunctionScope* functionScope = dynamic_cast<FunctionScope*>(scope);
            return functionScope->getFunction();
        }
    }
    return NULL;
}


/**
* this function validates that we return from a function
* and the expression is of the same type as the function returned type.
*/
void validateFunctionReturnType(Expression* exp){
    FuncDec* func=getFunction();
    if( (NULL == func)
    ||(exp==NULL && !isInstanceOf<Void>(func->returnType))
    ||(exp!=NULL && (exp->type->typeName()!= func->returnType->typeName()))){
        errorMismatch(yylineno);
        exit(1);
    }
    if(exp!=NULL)
        delete exp;
}

Call* handleCall(Id* id,ExpressionList* expList){
    FuncDec* func=symbolTable.back()->getFunction(id);

    if(NULL == func){
        errorUndefFunc(yylineno,id->name);
        exit(1);
    }

    if(!func->isArgumentListMatch(expList)){
        vector<string>* strVec = func->getArgsAsString();
        vector<string>& v = *strVec;
        errorPrototypeMismatch(yylineno,id->name,v);
        delete strVec;
        exit(1);
    }
    return new Call(func->returnType,id,expList);
}

/*
**this function validate assignment to id by comparing exp type.
** this function assume that id type is updated.
*/
void validateAssignment(Id* id,Expression* exp){
    if(id->type->typeName() !=  exp->type->typeName()){
        errorMismatch(yylineno);
        exit(1);
    }

}

void assertIdentifierNotExists(Id *id){
     Scope * scope = symbolTable.back();
     if(scope->getVariable(id)!=NULL){
        errorDef(yylineno, id->name);
        exit(1);
     }
}

void insertVarToTable(Id* id){
    assertIdentifierNotExists(id);
    int newOffset=offsets.back();
    offsets.pop_back();
    offsets.push_back(newOffset+1);
    id->offset=newOffset;
    symbolTable.back()->addVariable(id);
}

void handleTypeDecl(Type* type,Id* id){
    id->updateType(type);
    insertVarToTable(id);

}

void handleArgumentDecl(FormalList* formalList){

     int offset=-1;
     vector<FormalDec *>::iterator it=formalList->decelerations.begin();
     while(formalList->decelerations.end() != it){
        FormalDec* formalDec=*it;
        Id* id= new Id(formalDec->id);
        id->offset=offset;
        symbolTable.back()->addVariable(id);
        --offset;
        ++it;
     }
}
/**
** This function extracts the id from symbol table.
** if id does not exist the function will exit with error
*/
Id* extractIdFromSymbolTable(Id* id){
    Id* i=symbolTable.back()->getVariable(id);
    if(NULL==i){
        errorUndef(yylineno,id->name);
        exit(1);
    }
    return i;
}

void handleIDExpression(Id* id){
    Id* idFromSymbolTable=extractIdFromSymbolTable(id);
    id->offset=idFromSymbolTable->offset;
}

void assignToVar(Id* id,Expression* exp){
    Id* idFromSymbolTable=extractIdFromSymbolTable(id);
    if(idFromSymbolTable->isFunction()){
        errorUndef(yylineno,id->name);
        exit(1);
    }
    validateAssignment(idFromSymbolTable,exp);
    delete id;
    delete exp;
}

void handleIf(Expression* exp){
    validateExpIsBool(exp);
    symbolTable.back()->endScope();
    delete exp;
}



bool operator==(const Id& a,const Id& b){
    return a.name==b.name;
}
bool operator!=(const Id& a,const Id& b){
    return a.name!=b.name;
}

bool operator==(const FuncDec& a,const FuncDec& b){
    return a.id==b.id;
}
bool operator!=(const FuncDec& a,const FuncDec& b){
    return a.id!=b.id;
}