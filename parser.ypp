%{
	#define YYDEBUG 1
	#define YYERROR_VERBOSE 1
	#include <iostream>
	#include <stdlib.h>
	#include "parser.hpp"
	#include "main.hpp"
	#include "output.hpp"
	#include <stdio.h>
	extern int yylineno;
	extern int yylex();
	int yyerror(const char * message);
	using namespace FanC;
%}

%left ASSIGN
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%nonassoc IFPREC
%left ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token PRECOND
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%left OR
%left AND
%nonassoc EQUALITY
%nonassoc RELATIONAL
%left ADDITIVE 
%left MULTIPLICATIVE 
%token LPAREN
%token RPAREN


%%

Program:	OpenScope Funcs	{
    reduceProgram();

}
;

Funcs: /*epsilon*/ {}
	| FuncDecl Funcs	{} 
;

FuncDecl:	FuncDeclSignature PreConditionsDecl LBRACE  Statements RBRACE {reduceFuncDecl();}
;

FuncDeclSignature:OpenFunctionScope RetType ID LPAREN Formals RPAREN  {
     ReturnType* returnType=dynamic_cast<ReturnType*>($2);
     Id* id=dynamic_cast<Id*>($3);
     FormalList* formals=dynamic_cast<FormalList*>($5);
     reduceFuncDeclSignature(returnType,id,formals);
}
;

PreConditionsDecl: PreConditions {
     PreConditions* preconditions=dynamic_cast<PreConditions*>($1);
     reducePreConditionsDecl(preconditions);
};

RetType:	Type {$$ = $1;}
	|		VOID {$$ = new Void();}
;

Formals:	/*epsilon*/ {$$ = new FormalList();}
	| 	FormalsList {handleArgumentDecl((FormalList*)$1);$$ = (FormalList*)$1;}
;

FormalsList:	FormalDecl	{$$=new FormalList((FormalDec*)$1);}
	|	FormalDecl	COMMA FormalsList {$$=(((FormalList*)$3)->add((FormalDec*)$1));}
;

FormalDecl:	Type ID {
    Type* type=(Type*)$1;
    Id* id=(Id*)$2;
    reduceFormalDecl(type,id);
    $$=new FormalDec(type,id);
}
;

PreConditions:	/*epsilon*/ {$$=new PreConditions();}
	|	PreConditions PreCondition {$$=reducePreConditions((PreConditions*)$1,(PreCondition*)$2);}
;

PreCondition:	PRECOND LPAREN Exp RPAREN {validateExpIsBool((Expression*)$3); $$=new PreCondition((Expression*)$3);}
;

Statements: Statement	{}
	|	Statements Statement {}
;

Statement: LBRACE OpenScope Statements RBRACE	{reduceStatement();}
	|	Type ID	SC	{handleTypeDecl((Type*)$1,(Id*)$2);}
	|	Type ID ASSIGN Exp SC	{handleTypeDecl((Type*)$1,(Id*)$2);validateAssignment((Id*)$2,(Expression*)$4); delete $4;}
	|	ID ASSIGN Exp SC	{assignToVar((Id*)$1,(Expression*)$3);}
	|	Call SC	{delete $1; }
	|	RETURN SC	{validateFunctionReturnType(NULL);}
	|	RETURN Exp SC	{validateFunctionReturnType((Expression*)$2);}
	|	IF LPAREN Exp RPAREN OpenScope Statement ELSE EndScope OpenScope Statement 	{handleIf((Expression*)$3);}
	|	IF LPAREN Exp RPAREN OpenScope Statement %prec IFPREC {handleIf((Expression*)$3);}
	|	WHILE LPAREN Exp RPAREN OpenWhileScope Statement	{handleWhile((Expression*)$3);}
	|	BREAK SC	{validateWhile(Break);}
	|	CONTINUE SC	{validateWhile(Continue);}
;

Call:	ID LPAREN ExpList RPAREN	{$$=handleCall((Id*)$1,(ExpressionList*)$3);}
	|	ID LPAREN RPAREN	{$$ = handleCall(((Id*)$1),new ExpressionList());}
;

ExpList: Exp	{$$=new ExpressionList((Expression*)$1);}
	|	Exp COMMA ExpList	{$$=((ExpressionList*)$3)->add((Expression*)$1);}
;

Type: INT	{$$=new IntType();}
	| BYTE	{$$=new ByteType();}
	| BOOL	{$$=new BooleanType();}
;

Exp:	LPAREN Exp RPAREN	{$$ = $2;}
	|	Exp MULTIPLICATIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	Exp ADDITIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	ID		{handleIDExpression((Id*)$1);$$ = (Id*)$1;}
	|	Call	{$$ = (Call*)$1; }
	|	NUM B	{$$ = new Byte((Number*)$1); }
	|	NUM		{$$ = new Integer((Number*)$1); }
	|	STRING	{$$ = (String*)$1;}
	|	TRUE	{$$ = new Boolean(true);}
	|	FALSE	{$$ = new Boolean(false);}
	|	NOT Exp	{$$ = new Not((Expression*)$2);}
	|	Exp AND Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(And));}
	|	Exp OR Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(Or));}
	|	Exp RELATIONAL Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);}
	|	Exp EQUALITY Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);}
;

OpenWhileScope: /*epsilon*/ {reduceOpenWhileScope();}
;

OpenScope: /*epsilon*/ {reduceOpenScope();}
;

OpenFunctionScope: /*epsilon*/ {reduceOpenFunctionScope();}
;

EndScope: /*epsilon*/ {reduceEndScope();}
;


%%

/* Code Section */

int main(){
    //yydebug=1 // uncomment this inorder to debug
    //freopen ("hw3-tests/t1.in","r",stdin);
    return yyparse();
}
int yyerror(const char * message){
    errorSyn(yylineno);
    exit(1);
}