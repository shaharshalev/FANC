%{
	#define YYDEBUG 1
	#define YYERROR_VERBOSE 1
	#include <iostream>
	#include <stdlib.h>
	#include "fanC.hpp"
	#include "output.hpp"
	extern int yylineno;
	int yyerror(const char * message);
	int yylex();
	void handleWhile(Expression* exp);
	void validateExpIsBool(Expression* exp);
	void validateWhile(WhileOp op);
    bool inWhile();
    void validateFunctionReturnType(Expression* exp);
    void validateCall(Call* call);
    void validateAssignment(Id* id,Expression* exp);
    void insertVarToTable(Id* id);
    void handleTypeDecl(Type* type,Id* id);
    Id* extractIdFromSymbolTable(Id* id);

	vector<Scope*> symbolTable;
	vector<int> offsets;
%}

%left ASSIGN
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%nonassoc IFPREC
%left ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token PRECOND
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%left OR
%left AND
%nonassoc EQUALITY
%nonassoc RELATIONAL
%left ADDITIVE 
%left MULTIPLICATIVE 
%token LPAREN
%token RPAREN


%%

Program:	OpenScope Funcs	{symbolTable.back()->endScope(); /*End global scope*/}
;

Funcs: /*epsilon*/ {}
	| FuncDecl Funcs	{} 
;

FuncDecl:	FuncDeclSignature LBRACE  Statements RBRACE {symbolTable.back()->endScope();}
;

FuncDeclSignature: RetType ID LPAREN Formals RPAREN PreConditions {
      ReturnType* returnType=dynamic_cast<ReturnType*>($1);
      Id* id=dynamic_cast<Id*>($2);
      FormalList* formals=dynamic_cast<FormalList*>($4);
      PreConditions* preconditions=dynamic_cast<PreConditions*>($6);

    symbolTable.push_back(
    new FunctionScope(symbolTable.back(),
                        new FuncDec(returnType,id,formals,preconditions)
    ));
}
;

RetType:	Type {$$ = $1;}
	|		VOID {$$ = new Void();}
;

Formals:	/*epsilon*/ {$$ = new FormalList();}
	|	FormalsList {$$ = (FormalList*)$1;}
;

FormalsList:	FormalDecl	{$$=new FormalList((FormalDec*)$1);}
	|	FormalDecl	COMMA FormalsList {$$=((FormalList*)$3)->add((FormalDec*)$1);}
;

FormalDecl:	Type ID {handleTypeDecl((Type*)$1,(Id*)$2);$$=new FormalDec((Type*)$1,(Id*)$2);}
;

PreConditions:	/*epsilon*/ {$$=new PreConditions();}
	|	PreConditions PreCondition {$$=((PreConditions*)$1)->add((PreCondition*)$2);}
;

PreCondition:	PRECOND LPAREN Exp RPAREN {validateExpIsBool((Expression*)$3); $$=new PreCondition((Expression*)$3);}
;

Statements: Statement	{}
	|	Statements Statement {}
;

Statement: LBRACE OpenScope Statements RBRACE	{symbolTable.back()->endScope();}
	|	Type ID	SC	{handleTypeDecl((Type*)$1,(Id*)$2);insertVarToTable((Id*)$2);}
	|	Type ID ASSIGN Exp SC	{handleTypeDecl((Type*)$1,(Id*)$2);validateAssignment((Id*)$2,(Expression*)$4); }
	|	ID ASSIGN Exp SC	{extractIdFromSymbolTable((Id*)$1);validateAssignment((Id*)$1,(Expression*)$3);}
	|	Call SC	{validateCall((Call*)$1);}
	|	RETURN SC	{validateFunctionReturnType(NULL);}
	|	RETURN Exp SC	{validateFunctionReturnType((Expression*)$2);}
	|	IF LPAREN Exp RPAREN OpenScope Statement ELSE EndScope OpenScope Statement 	{validateExpIsBool((Expression*)$3);symbolTable.back()->endScope();}
	|	IF LPAREN Exp RPAREN OpenScope Statement %prec IFPREC {validateExpIsBool((Expression*)$3);symbolTable.back()->endScope();}
	|	WHILE LPAREN Exp RPAREN OpenWhileScope Statement	{handleWhile((Expression*)$3);symbolTable.back()->endScope();}
	|	BREAK SC	{validateWhile(Break);}
	|	CONTINUE SC	{validateWhile(Continue);}
;
//todo: CHANGE RETURN TYPE TO REAL TYPE AFTER SEARCHING IN SYMBOL TABLE
Call:	ID LPAREN ExpList RPAREN	{$$=new Call(new ReturnType(),((Id*)$1),((ExpressionList*)$3));}
	|	ID LPAREN RPAREN	{$$=new Call(new ReturnType(),((Id*)$1),new ExpressionList());}
;

ExpList: Exp	{$$=new ExpressionList((Expression*)$1);}
	|	Exp COMMA ExpList	{$$=((ExpressionList*)$3)->add((Expression*)$1);}
;

Type: INT	{$$=new IntType();}
	| BYTE	{$$=new ByteType();}
	| BOOL	{$$=new BooleanType();}
;

Exp:	LPAREN Exp RPAREN	{$$ = $2;}
	|	Exp MULTIPLICATIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	Exp ADDITIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	ID		{$$ = (Id*)$1;}
	|	Call	{$$ = (Call*)$1;}
	|	NUM B	{$$ = new Byte((Number*)$1); }
	|	NUM		{$$ = new Integer((Number*)$1); }
	|	STRING	{$$ = (String*)$1;}
	|	TRUE	{$$ = new Boolean(true);}
	|	FALSE	{$$ = new Boolean(false);}
	|	NOT Exp	{$$ = new Not((Expression*)$2);}
	|	Exp AND Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(And));}
	|	Exp OR Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(Or));}
	|	Exp RELATIONAL Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);}
	|	Exp EQUALITY Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);}
;

OpenWhileScope: /*epsilon*/ {
    symbolTable.push_back(new WhileScope(symbolTable.back()));
    //TODO insert in offsets
}
;




OpenScope: /*epsilon*/ {
    if(symbolTable.empty())
        symbolTable.push_back(new Scope(NULL));
    else{
        symbolTable.push_back(new Scope(symbolTable.back()));
    }
    //TODO add to offset table
 }
;

EndScope: /*epsilon*/ {
    Scope* currentScope = symbolTable.back();
    symbolTable.pop_back();
    currentScope->endScope();
    delete currentScope;

    //TODO remove offset;
}
;





%%

int main(){
	//yydebug=1 // uncomment this inorder to debug
	return yyparse();
}
int yyerror(const char * message){
	errorSyn(yylineno);
	exit(1);
}

void validateWhile(WhileOp op){
    if(inWhile()){
        switch(op){
            case Break:
                errorUnexpectedBreak(yylineno);
            break;
            case Continue:
                errorUnexpectedContinue(yylineno);
            break;
        }
    }
}
void validateExpIsBool(Expression* exp){
  if(!isInstanceOf<BooleanType>(exp)){
       errorMismatch(yylineno);
       exit(1);
  }
}

void handleWhile(Expression* exp){

 validateExpIsBool(exp);


}
bool inWhile(){
    //TODO: check if we are in a while in a symbol table and return accordingly
}

void validateFunctionReturnType(Expression* exp){
    //TODO: validate in symbol table that we are inside a function of the same Type of exp
    // also make sure to delete it afterwards
}

void validateCall(Call* call){
    //TODO: validate that call id exist in symbol type (errorUndefFunc)
    // also make sure to delete it afterwards
}

/*
**this function validate assignment to id by comparing exp type.
** this function assume that id type is updated.
*/
void validateAssignment(Id* id,Expression* exp){
    if(typeid(id->type).name() !=  typeid(exp->type).name()){
        errorMismatch(yylineno);
        exit(1);
    }

}

void insertVarToTable(Id* id){
    symbolTable.back()->addVariable(id);
    //TODO insert to offsets
}

void handleTypeDecl(Type* type,Id* id){
    id->updateType(type);
    insertVarToTable(id);

}

Id* extractIdFromSymbolTable(Id* id){
    Id* updatedId=symbolTable.back()->getVariable(id);
    if(NULL==id){

    }
}

bool operator==(const Id& a,const Id& b){
    return a.name==b.name;
}

bool operator==(const FuncDec& a,const FuncDec& b){
    return a.id==b.id;
}