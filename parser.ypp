%{
	#define YYDEBUG 1
	#define YYERROR_VERBOSE 1
	#include <iostream>
	#include <stdlib.h>
	#include "parser.hpp"
	#include "main.hpp"
	#include "output.hpp"
	#include <stdio.h>
	extern int yylineno;
	extern int yylex();

	using namespace FanC;
%}

%left ASSIGN
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%nonassoc IFPREC
%left ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token PRECOND
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%left OR
%left AND
%nonassoc EQUALITY
%nonassoc RELATIONAL
%left ADDITIVE 
%left MULTIPLICATIVE 
%token LPAREN
%token RPAREN


%%

Program:	InitProgram OpenScope Funcs	{reduceProgram();}
;

InitProgram:    {initProgramHeader();}
;

Funcs: /*epsilon*/ {}
	| FuncDecl Funcs	{} 
;

FuncDecl:	FuncDeclSignature PreConditionsDecl LBRACE  Statements RBRACE {reduceFuncDecl();}
;

FuncDeclSignature:OpenFunctionScope RetType ID LPAREN Formals RPAREN  {
     ReturnType* returnType=dynamic_cast<ReturnType*>($2);
     Id* id=dynamic_cast<Id*>($3);
     FormalList* formals=dynamic_cast<FormalList*>($5);
     reduceFuncDeclSignature(returnType,id,formals);
}
;

PreConditionsDecl: PreConditions {
     PreConditions* preconditions=dynamic_cast<PreConditions*>($1);
     reducePreConditionsDecl(preconditions);
};

RetType:	Type {$$ = $1;}
	|		VOID {$$ = new Void();}
;

Formals:	/*epsilon*/ {$$ = new FormalList();}
	| 	FormalsList {handleArgumentDecl((FormalList*)$1);$$ = (FormalList*)$1;}
;

FormalsList:	FormalDecl	{$$=new FormalList((FormalDec*)$1);}
	|	FormalDecl	COMMA FormalsList {$$=reduceFormalsList((FormalList*)$3,(FormalDec*)$1);}
;

FormalDecl:	Type ID {
    Type* type=(Type*)$1;
    Id* id=(Id*)$2;
    reduceFormalDecl(type,id);
    $$=new FormalDec(type,id);
}
;

PreConditions:	/*epsilon*/ {$$=new PreConditions();}
	|	PreConditions PreCondition {$$=reducePreConditions((PreConditions*)$1,(PreCondition*)$2);}
;

PreCondition:	PRECOND LPAREN Exp RPAREN {validateExpIsBool((Expression*)$3); $$=new PreCondition((Expression*)$3);}
;

Statements: Statement	{}
	|	Statements Statement {}
;

Statement: LBRACE OpenScope Statements RBRACE	{reduceStatement();}
	|	Type ID	SC	{handleTypeDecl((Type*)$1,(Id*)$2);initVariableInStack();}
	|	Type ID ASSIGN Exp SC	{handleTypeDecl((Type*)$1,(Id*)$2);validateAssignment((Id*)$2,(Expression*)$4);handleRegisterInAssignmentDecl((Expression*)$4);}
	|	ID ASSIGN Exp SC	{assignToVar((Id*)$1,(Expression*)$3);}
	|	Call SC	{delete $1; }
	|	RETURN SC	{validateFunctionReturnType(NULL);}
	|	RETURN Exp SC	{validateFunctionReturnType((Expression*)$2); /* todo move reg to v0 and check if bool*/}
	|	IF  OpenIfScope Statement ELSE EndScope OpenScope Statement 	{reduceEndScope();}
	|	IF  OpenIfScope Statement %prec IFPREC {reduceEndScope();}
	|	WHILE  OpenWhileScope Statement	{handleWhile();}
	|	BREAK SC	{validateWhile(Break);}
	|	CONTINUE SC	{validateWhile(Continue);}
;

Call:	ID LPAREN ExpList RPAREN	{$$=handleCall((Id*)$1,(ExpressionList*)$3);}
	|	ID LPAREN RPAREN	{$$ = handleCall(((Id*)$1),new ExpressionList());}
;

ExpList: Exp	{changeBranchToVar((Expression*)$1);$$=new ExpressionList((Expression*)$1);}
	|	Exp COMMA ExpList	{changeBranchToVar((Expression*)$1);$$=((ExpressionList*)$3)->add((Expression*)$1);}
;

Type: INT	{$$=new IntType();}
	| BYTE	{$$=new ByteType();}
	| BOOL	{$$=new BooleanType();}
;

Exp:	LPAREN Exp RPAREN	{$$ = $2;}
	|	Exp MULTIPLICATIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	Exp ADDITIVE Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(BinaryOperation*)$2);}
	|	ID		{handleIDExpression((Id*)$1);$$ = (Id*)$1;/*allocate reg*/}
	|	Call	{$$ = (Call*)$1; saveReturnValueInCallRegister((Call*)$1);/*allocate reg*/ }
	|	NUM B	{$$ = new Byte((Number*)$1); /*allocate reg*/}
	|	NUM		{$$ = new Integer((Number*)$1); /*allocate reg*/}
	|	STRING	{$$ = (String*)$1;  /*allocate reg*/}
	|	TRUE	{$$ = new Boolean(true);/*allocate reg*/}
	|	FALSE	{$$ = new Boolean(false);/*allocate reg*/}
	|	NOT Exp	{$$ = new Not((Expression*)$2);}
	|	Exp AND Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(And));}
	|	Exp OR Exp	{$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,new BooleanOperation(Or));}
	|	Exp RELATIONAL Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);/*allocate reg*/}
	|	Exp EQUALITY Exp {$$ = new BinaryExpression((Expression*)$1,(Expression*)$3,(Relop*)$2);/*allocate reg*/}
;

OpenWhileScope: LPAREN Exp RPAREN {reduceOpenWhileScope((Expression*)$2);}
;

OpenScope: /*epsilon*/ {reduceOpenScope();}
;

OpenIfScope: LPAREN Exp RPAREN  {reduceOpenIfScope((Expression*)$2);}
;

OpenFunctionScope: /*epsilon*/ {reduceOpenFunctionScope();}
;

EndScope: /*epsilon*/ {reduceEndScope();}
;


%%

/* Code Section */

int main(){
    //yydebug=1 // uncomment this inorder to debug
    //freopen ("tests/staff/t29.in","r",stdin);
    return yyparse();
}



